---
layout:     post
title:      Java Problem Solving - Two pointer 
author:     Soo-young Hwang
tags: 		JAVA
subtitle:  	Two pointer 활용 문제 해결을 위한 알고리즘 기초
category:   study
published: true
---

# Two pointers

투포인터 알고리즘은 리스트에 순차적으로 접근해야 할 때2개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다.

> 투포인터 알고리즘을 이용해 풀 수 있는 문제 유형
>
> (투포인터 알고리즘은 구현 가능한 방식이 매우 많음)

### 문제1) 특정한 합(M)을 가지는 부분 연속 수열 경우의 수 찾기

- 부분 연속 수열의 시작점과 끝점 start, end 가 인덱스 0 을 가리킨다
- 현재 부분 합이 M과 같다면 카운트
- 현재 부분 합이 M보다 작으면 end 를 1 증가
    - 부분합 늘리기
- 현재 부분합이 M보다 크거나 같으면 start를 1증가
    - 부분합 줄이기
- 모든 경우를 확인할 때 까지 반복


이 문제를 투포인터 알고리즘으로 해결할 수 있는 이유는 기본적으로
시작점을 오른쪽으로 이동시키면 항상 합이 감소하고,
끝점을 오른쪽으로 이동시키면 항상 합이 증가하기 때문이다.

*만약에 리스트 내 원소에 음수 데이터가 포함되어 있는 경우에는 투 포인터 알고리즘으로 문제를 해결할 수 없다.

### 문제2) 정렬되어 있는 두 리스트의 합집합

*무조건 정렬이 되어 있어야 한다.

- 정렬된 리스트  A, B
- 리스트 A에서 처리되지 않은 원소중 가장 작은 원소를 i가 가리킨다
- 리스트 B에서 처리되지 않은 원소중 가장 작은 원소를 j가 가리킨다
- A[i], B[j] 중 더 작은 원소를 결과리스트에 담는다
- 처리할 원소가 없을 때 까지 반복


**이 알고리즘의 시간 복잡도는 O(N+M)**        
=> 단순히 각 리스트의 모든 원소를 한 번씩만 순회하면 되기 때문에

이 알고리즘의 경우 병합 정렬과 같은 일부 알고리즘에서 사용되고 있다.

### 문제3) 정렬되어 있는 두 리스트의 교집합

*무조건 정렬이 되어 있어야 한다.

- 정렬된 리스트  A, B
- 리스트 A에서 처리되지 않은 원소중 가장 작은 원소를 i가 가리킨다
- 리스트 B에서 처리되지 않은 원소중 가장 작은 원소를 j가 가리킨다
- A[i], B[j] 같으면 결과리스트에 담는다.
- A[i] < B[j], 값이 작은 배열의 포인터 i를 증가시킨다
- 혹은, A[i] > B[j], 값이 작은 배열의 포인터 j를 증가시킨다
- 둘 중 하나의 포인터가 끝에 다다르면 종료

```java
  public List<Integer> solution(int n, int m, int[] arrA, int[] arrB) {
    List<Integer> answer = new ArrayList<>();
    int p1 = 0, p2 = 0;

    Arrays.sort(arrA); // 오름차순 정렬
    Arrays.sort(arrB); // 오름차순 정렬

    while(p1<n && p2 <m){
      if(arrA[p1] == arrB[p2]) {
        answer.add(arrA[p1]);
        p1++;
        p2++;
      } else if (arrA[p1] < arrB[p2]) p1++;
       else if (arrA[p1] > arrB[p2]) p2++;
    }

    return answer;
  }
```


이러한 문제는 코딩 인터뷰에서 손코딩 문제로 출제될 수 있으니 잘 기억하고 있자.
  




